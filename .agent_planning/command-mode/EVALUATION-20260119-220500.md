# EVALUATION: Interactive Command Mode for long-term

**Topic**: Interactive Command Mode
**Generated**: 2026-01-19 22:05:00
**Evaluator**: Explore Agent (a54aee1)

---

## 1. WHAT EXISTS - Current Architecture

**Current Implementation (main.go, ~236 lines):**

The codebase is a single-file Go program with a clean, focused architecture:

- **Argument parsing (lines 20-65)**: Handles `-height` (fixed) and `-delta` (relative) flags with explicit sign validation
- **PTY creation (lines 172-180)**: Uses `creack/pty` library to spawn wrapped command with fake dimensions
- **Signal handling (lines 183-210)**: SIGWINCH handler responsive to terminal resize events, recalculating dimensions based on toggle state
- **I/O proxying (lines 223-232)**: Two goroutines handle bidirectional copying (stdin→pty, pty→stdout) with raw terminal mode
- **Runtime toggle (lines 76-120, 149-156)**: Uses `io.TeeReader` to observe stdin for Ctrl+\ (0x1C) pressed 3 times within 500ms, toggling between fake and real height via atomic bool flag

**Key architectural decisions:**
- Terminal put into raw mode (line 214-219) - direct byte-level I/O, no line buffering
- `io.TeeReader` for non-invasive magic key detection (passes all bytes through unchanged)
- Atomic bool for lock-free toggle state coordination between input detection and SIGWINCH handler
- Separate goroutines for I/O proxying and signal handling (concurrent, no blocking)
- Width always passes through from real terminal; only height is faked

**Dependencies:**
```
github.com/creack/pty v1.1.24      - PTY spawning and size control
golang.org/x/term                   - Terminal mode detection and raw mode
golang.org/x/sys                    - Low-level system calls (indirect)
```

---

## 2. WHAT'S MISSING FOR COMMAND MODE

**Interactive UI Requirements:**

1. **Interactive UI Rendering**
   - Needs to draw to `/dev/tty` (separate from wrapped process's stdin/stdout)
   - Positioning requires ANSI escape codes (cursor movement, clearing)
   - Multi-line display of settings and controls
   - Real-time updates as values change

2. **Keyboard Input Parsing**
   - Arrow keys (UP/DOWN=adjust values)
   - Escape sequences (0x1B followed by multiple bytes for special keys)
   - Modifiers (Shift, Ctrl) for different adjustment increments
   - Numeric input buffering for direct height/delta entry (n/d commands)
   - ESC to exit command mode, space to toggle

3. **State Machine for Modes**
   - Normal mode: I/O passthrough, listen for magic sequence
   - Command mode: intercept keyboard input, render UI
   - Transition triggers: Magic sequence enters, ESC exits

4. **Live UI Updates**
   - Current height setting (fake vs real)
   - Current delta offset
   - Terminal size detected
   - Numeric input buffer visualization
   - Available commands display

5. **Input Buffering for Numeric Entry**
   - 'n' or 'd' enters numeric mode
   - Accumulate digit characters (0-9, backspace)
   - Allow +/- prefix for delta mode
   - Enter applies new value

---

## 3. TECHNICAL CHALLENGES

**Critical Implementation Challenges:**

1. **Dual Output Streams**
   - Wrapped process writes to stdout
   - Command mode UI renders overlays
   - **Solution**: Use `/dev/tty` for UI (separate from stdin/stdout redirects)
   - **Risk**: If `/dev/tty` unavailable (piped context), command mode fails

2. **Escape Sequence Parsing**
   - Arrow keys send multi-byte sequences (`ESC [ A`, `ESC [ B`, etc.)
   - Must handle timeout (user types ESC alone vs. ESC as start of sequence)
   - State machine with 50-100ms timeout needed

3. **Race Conditions**
   - Multiple goroutines: input detection, SIGWINCH handler, UI renderer
   - Shared state: useRealSize, current height/delta, command mode flag
   - **Risks**: Concurrent /dev/tty writes, state corruption
   - **Mitigation**: Atomic values, channel-based coordination

4. **Terminal Compatibility**
   - Different ANSI code support across terminals
   - Cursor positioning varies
   - **Mitigation**: Test on iTerm2, Terminal.app, xterm, Linux console

5. **I/O Buffering and Timing**
   - Raw mode: unbuffered byte-by-byte
   - UI needs atomic rendering
   - **Solution**: Buffer UI updates, single write to /dev/tty

6. **Screen State Management**
   - Save cursor position on entry
   - Restore on exit
   - Handle wrapped process cursor movement

---

## 4. DEPENDENCIES AND RISKS

**New Dependencies Consideration:**

Option A: No new dependencies (pure ANSI codes)
- Pros: Small binary, full control
- Cons: More code, terminal compatibility complexity

Option B: Terminal UI library
- `github.com/charmbracelet/lipgloss` for styling
- `github.com/nsf/termbox-go` for low-level terminal access
- Pros: Cleaner code, better terminal compat
- Cons: Larger binary, more dependencies

**Recommendation**: Option A (no new deps) to match project's minimalist philosophy

**Integration Risks:**

1. **Magic Sequence + Escape Sequences**: Both active simultaneously, timing sensitive
2. **PTY Size Changes During Command Mode**: SIGWINCH while UI visible
3. **Signal Handling**: SIGINT, SIGTERM during command mode
4. **Raw Mode Interaction**: Ctrl+C won't work normally

---

## 5. AMBIGUITIES AND UNKNOWNS

**Design Questions Requiring Resolution:**

### Question 1: I/O Behavior During Command Mode
**Options:**
- **A) Pause I/O**: Don't forward input to wrapped process during command mode
  - Pros: Clean UI, no corruption
  - Cons: Wrapped process feels unresponsive
- **B) Selective**: Forward non-keyboard input only
  - Pros: Pipes still work
  - Cons: Complex to implement
- **C) Full passthrough**: Keep forwarding everything
  - Pros: Simple
  - Cons: UI corrupted, confusing UX

**Recommendation**: Option A (pause I/O)

### Question 2: Wrapped Process Output While UI Visible
**Options:**
- **A) Buffer output**: Queue output, display after exit
  - Pros: Clean UI
  - Cons: Lose real-time output
- **B) Alternate screen buffer**: UI on separate buffer
  - Pros: Clean separation
  - Cons: Terminal compatibility
- **C) Overlay**: Allow output to scroll
  - Pros: Real-time
  - Cons: UI corruption, refresh needed

**Recommendation**: Option B (alternate screen) or A (buffering)

### Question 3: UI Layout Position
User specified: "1/4 of the way from the top on the right side"
- Calculate as `row = terminal_height / 4`, `col = terminal_width - box_width`
- Box width ~40 columns for content

### Question 4: Numeric Input Confirmation
- Auto-confirm on Enter (show preview first)
- Live preview as user types
**Recommendation**: Show preview, confirm with Enter

### Question 5: Entry/Exit Discovery
How does user know command mode exists?
- Display hint on startup?
- In-command help with '?'?
**Recommendation**: Brief startup hint + in-command help

---

## 6. VERDICT

**Status**: PAUSE

**Reason**: Several design ambiguities need user input before implementation

**Required Clarifications**:
1. I/O behavior during command mode (pause vs. passthrough)
2. Wrapped output handling (buffer vs. alternate screen)
3. Confirm UI layout details (exact positioning, content)
4. Startup hints acceptable?

**Once resolved**: Confidence level will be HIGH for implementation

---

## 7. SUCCESS CRITERIA (VERIFIABLE)

**Functional Tests:**
- [ ] Magic sequence (Ctrl+\×3) enters command mode
- [ ] ESC exits command mode
- [ ] UP/DOWN arrows adjust height by 1
- [ ] Shift+UP/DOWN adjust by 20
- [ ] Shift+Ctrl+UP/DOWN adjust by 200
- [ ] 'n' allows numeric height entry
- [ ] 'd' allows numeric delta entry (+/- required)
- [ ] Space toggles fake/real height
- [ ] 'r' resets to default
- [ ] SIGWINCH updates UI and PTY during command mode
- [ ] No UI corruption when wrapped process outputs

**Integration Tests:**
- [ ] Works with bash, vim, tmux
- [ ] Terminal resize handled correctly
- [ ] Clean shutdown (Ctrl+C restores terminal)

**Non-Functional:**
- [ ] No race conditions (go test -race)
- [ ] No goroutine leaks
- [ ] Tested on iTerm2, Terminal.app, xterm

**Code Quality:**
- [ ] No new dependencies beyond creack/pty, golang.org/x/term
- [ ] State machine documented
- [ ] Escape sequence parsing documented

---

## 8. RECOMMENDED IMPLEMENTATION PHASES

### Phase 1: Input Parsing
- Extend magicDetector to keyboard parser
- State machine: Normal ↔ Command mode
- Test input validation

### Phase 2: UI Rendering
- `/dev/tty` writer
- ANSI-based modal box
- Display current settings

### Phase 3: Commands
- Arrow key navigation
- Space toggle
- Numeric input (n/d commands)
- ESC exit

### Phase 4: Integration
- SIGWINCH in command mode
- Output buffering/alternate screen
- Screen state save/restore
- Comprehensive testing

**Estimated Complexity**: Medium (~500-700 total lines)
